"use strict";
var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.tagsActions = exports.selectTagSelectOptions = exports.selectTagById = exports.selectTags = exports.tagsUpdateEpic = exports.tagsSortEpic = exports.tagsListenerUpdateQueueEpic = exports.tagsListenerDeleteQueueEpic = exports.tagsListenerCreateQueueEpic = exports.tagsFetchEpic = exports.tagsDeleteEpic = exports.tagsCreateEpic = void 0;
var toolkit_1 = require("@reduxjs/toolkit");
var groq_1 = __importDefault(require("groq"));
var redux_observable_1 = require("redux-observable");
var rxjs_1 = require("rxjs");
var operators_1 = require("rxjs/operators");
var client_1 = require("../../client");
var constants_1 = require("../../constants");
var checkTagName_1 = __importDefault(require("../../operators/checkTagName"));
var debugThrottle_1 = __importDefault(require("../../operators/debugThrottle"));
var getTagSelectOptions_1 = __importDefault(require("../../utils/getTagSelectOptions"));
var assets_1 = require("../assets");
var dialog_1 = require("../dialog");
var initialState = {
    allIds: [],
    byIds: {},
    creating: false,
    creatingError: undefined,
    fetchCount: -1,
    fetching: false,
    fetchingError: undefined,
    panelVisible: true
};
var tagsSlice = toolkit_1.createSlice({
    name: 'tags',
    initialState: initialState,
    extraReducers: function (builder) {
        builder
            .addCase(dialog_1.dialogActions.showTagCreate, function (state) {
            delete state.creatingError;
        })
            .addCase(dialog_1.dialogActions.showTagEdit, function (state, action) {
            var tagId = action.payload.tagId;
            delete state.byIds[tagId].error;
        })
            .addMatcher(function (action) {
            return [
                assets_1.assetsActions.tagsAddComplete.type,
                assets_1.assetsActions.tagsAddError.type,
                assets_1.assetsActions.tagsRemoveComplete.type,
                assets_1.assetsActions.tagsRemoveError.type
            ].includes(action.type);
        }, function (state, action) {
            var tag = action.payload.tag;
            state.byIds[tag._id].updating = false;
        })
            .addMatcher(function (action) {
            return [
                assets_1.assetsActions.tagsAddRequest.type,
                assets_1.assetsActions.tagsRemoveRequest.type
            ].includes(action.type);
        }, function (state, action) {
            var tag = action.payload.tag;
            state.byIds[tag._id].updating = true;
        });
    },
    reducers: {
        createComplete: function (state, action) {
            var tag = action.payload.tag;
            state.creating = false;
            if (!state.allIds.includes(tag._id)) {
                state.allIds.push(tag._id);
            }
            state.byIds[tag._id] = {
                _type: 'tag',
                picked: false,
                tag: tag,
                updating: false
            };
        },
        createError: function (state, action) {
            state.creating = false;
            state.creatingError = action.payload.error;
        },
        createRequest: function (state, _action) {
            state.creating = true;
            delete state.creatingError;
        },
        deleteComplete: function (state, action) {
            var tagId = action.payload.tagId;
            var deleteIndex = state.allIds.indexOf(tagId);
            if (deleteIndex >= 0) {
                state.allIds.splice(deleteIndex, 1);
            }
            delete state.byIds[tagId];
        },
        deleteError: function (state, action) {
            var _a = action.payload, error = _a.error, tag = _a.tag;
            var tagId = tag === null || tag === void 0 ? void 0 : tag._id;
            state.byIds[tagId].error = error;
            state.byIds[tagId].updating = false;
        },
        deleteRequest: function (state, action) {
            var _a, _b;
            var tagId = (_b = (_a = action.payload) === null || _a === void 0 ? void 0 : _a.tag) === null || _b === void 0 ? void 0 : _b._id;
            state.byIds[tagId].picked = false;
            state.byIds[tagId].updating = true;
            Object.keys(state.byIds).forEach(function (key) {
                delete state.byIds[key].error;
            });
        },
        fetchComplete: function (state, action) {
            var tags = action.payload.tags;
            tags === null || tags === void 0 ? void 0 : tags.forEach(function (tag) {
                state.allIds.push(tag._id);
                state.byIds[tag._id] = {
                    _type: 'tag',
                    picked: false,
                    tag: tag,
                    updating: false
                };
            });
            state.fetching = false;
            state.fetchCount = tags.length || 0;
            delete state.fetchingError;
        },
        fetchError: function (state, action) {
            var error = action.payload.error;
            state.fetching = false;
            state.fetchingError = error;
        },
        fetchRequest: {
            reducer: function (state, _action) {
                state.fetching = true;
                delete state.fetchingError;
            },
            prepare: function () {
                // Construct query
                var query = groq_1.default(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n          {\n            \"items\": *[\n              _type == \"", "\"\n              && !(_id in path(\"drafts.**\"))\n            ] {\n              _createdAt,\n              _updatedAt,\n              _id,\n              _rev,\n              _type,\n              name\n            } | order(name.current asc),\n          }\n        "], ["\n          {\n            \"items\": *[\n              _type == \"", "\"\n              && !(_id in path(\"drafts.**\"))\n            ] {\n              _createdAt,\n              _updatedAt,\n              _id,\n              _rev,\n              _type,\n              name\n            } | order(name.current asc),\n          }\n        "])), constants_1.TAG_DOCUMENT_NAME);
                return { payload: { query: query } };
            }
        },
        // Queue batch tag creation
        listenerCreateQueue: function (_state, _action) {
            //
        },
        // Apply created tags (via sanity real-time events)
        listenerCreateQueueComplete: function (state, action) {
            var tags = action.payload.tags;
            tags === null || tags === void 0 ? void 0 : tags.forEach(function (tag) {
                state.byIds[tag._id] = {
                    _type: 'tag',
                    picked: false,
                    tag: tag,
                    updating: false
                };
                if (!state.allIds.includes(tag._id)) {
                    state.allIds.push(tag._id);
                }
            });
        },
        // Queue batch tag deletion
        listenerDeleteQueue: function (_state, _action) {
            //
        },
        // Apply deleted tags (via sanity real-time events)
        listenerDeleteQueueComplete: function (state, action) {
            var tagIds = action.payload.tagIds;
            tagIds === null || tagIds === void 0 ? void 0 : tagIds.forEach(function (tagId) {
                var deleteIndex = state.allIds.indexOf(tagId);
                if (deleteIndex >= 0) {
                    state.allIds.splice(deleteIndex, 1);
                }
                delete state.byIds[tagId];
            });
        },
        // Queue batch tag updates
        listenerUpdateQueue: function (_state, _action) {
            //
        },
        // Apply updated tags (via sanity real-time events)
        listenerUpdateQueueComplete: function (state, action) {
            var tags = action.payload.tags;
            tags === null || tags === void 0 ? void 0 : tags.forEach(function (tag) {
                if (state.byIds[tag._id]) {
                    state.byIds[tag._id].tag = tag;
                }
            });
        },
        // Set tag panel visibility
        panelVisibleSet: function (state, action) {
            var panelVisible = action.payload.panelVisible;
            state.panelVisible = panelVisible;
        },
        // Sort all tags by name
        sort: function (state) {
            state.allIds.sort(function (a, b) {
                var tagA = state.byIds[a].tag.name.current;
                var tagB = state.byIds[b].tag.name.current;
                if (tagA < tagB) {
                    return -1;
                }
                else if (tagA > tagB) {
                    return 1;
                }
                return 0;
            });
        },
        updateComplete: function (state, action) {
            var tag = action.payload.tag;
            state.byIds[tag._id].tag = tag;
            state.byIds[tag._id].updating = false;
        },
        updateError: function (state, action) {
            var _a = action.payload, error = _a.error, tag = _a.tag;
            var tagId = tag === null || tag === void 0 ? void 0 : tag._id;
            state.byIds[tagId].error = error;
            state.byIds[tagId].updating = false;
        },
        updateRequest: function (state, action) {
            var tag = action.payload.tag;
            state.byIds[tag === null || tag === void 0 ? void 0 : tag._id].updating = true;
        }
    }
});
// On tag create request:
// - async check to see if tag already exists
// - throw if tag already exists
// - otherwise, create new tag
var tagsCreateEpic = function (action$, state$) {
    return action$.pipe(operators_1.filter(tagsSlice.actions.createRequest.match), operators_1.withLatestFrom(state$), operators_1.mergeMap(function (_a) {
        var _b = __read(_a, 2), action = _b[0], state = _b[1];
        var _c = action.payload, assetId = _c.assetId, name = _c.name;
        return rxjs_1.of(action).pipe(debugThrottle_1.default(state.debug.badConnection), checkTagName_1.default(name), operators_1.mergeMap(function () {
            return client_1.client.observable.create({
                _type: constants_1.TAG_DOCUMENT_NAME,
                name: {
                    _type: 'slug',
                    current: name
                }
            });
        }), operators_1.mergeMap(function (result) { return rxjs_1.of(tagsSlice.actions.createComplete({ assetId: assetId, tag: result })); }), operators_1.catchError(function (error) {
            return rxjs_1.of(tagsSlice.actions.createError({
                error: {
                    message: (error === null || error === void 0 ? void 0 : error.message) || 'Internal error',
                    statusCode: (error === null || error === void 0 ? void 0 : error.statusCode) || 500
                },
                name: name
            }));
        }));
    }));
};
exports.tagsCreateEpic = tagsCreateEpic;
// On tag delete request
// - find referenced assets
// - remove tag from referenced assets in a sanity transaction
var tagsDeleteEpic = function (action$, state$) {
    return action$.pipe(operators_1.filter(tagsSlice.actions.deleteRequest.match), operators_1.withLatestFrom(state$), operators_1.mergeMap(function (_a) {
        var _b = __read(_a, 2), action = _b[0], state = _b[1];
        var tag = action.payload.tag;
        return rxjs_1.of(action).pipe(
        // Optionally throttle
        debugThrottle_1.default(state.debug.badConnection), 
        // Fetch assets which reference this tag
        operators_1.mergeMap(function () {
            return client_1.client.observable.fetch(groq_1.default(templateObject_2 || (templateObject_2 = __makeTemplateObject(["*[\n              _type in [\"sanity.fileAsset\", \"sanity.imageAsset\"]\n              && references(*[_type == \"media.tag\" && name.current == $tagName]._id)\n            ] {\n              _id,\n              _rev,\n              opt\n            }"], ["*[\n              _type in [\"sanity.fileAsset\", \"sanity.imageAsset\"]\n              && references(*[_type == \"media.tag\" && name.current == $tagName]._id)\n            ] {\n              _id,\n              _rev,\n              opt\n            }"]))), { tagName: tag.name.current });
        }), 
        // Create transaction which remove tag references from all matched assets and delete tag
        operators_1.mergeMap(function (assets) {
            var patches = assets.map(function (asset) { return ({
                id: asset._id,
                patch: {
                    // this will cause the transaction to fail if the document has been modified since it was fetched.
                    ifRevisionID: asset._rev,
                    unset: ["opt.media.tags[_ref == \"" + tag._id + "\"]"]
                }
            }); });
            var transaction = patches.reduce(function (tx, patch) { return tx.patch(patch.id, patch.patch); }, client_1.client.transaction());
            transaction.delete(tag._id);
            return rxjs_1.from(transaction.commit());
        }), 
        // Dispatch complete action
        operators_1.mergeMap(function () { return rxjs_1.of(tagsSlice.actions.deleteComplete({ tagId: tag._id })); }), operators_1.catchError(function (error) {
            return rxjs_1.of(tagsSlice.actions.deleteError({
                error: {
                    message: (error === null || error === void 0 ? void 0 : error.message) || 'Internal error',
                    statusCode: (error === null || error === void 0 ? void 0 : error.statusCode) || 500
                },
                tag: tag
            }));
        }));
    }));
};
exports.tagsDeleteEpic = tagsDeleteEpic;
// Async fetch tags
var tagsFetchEpic = function (action$, state$) {
    return action$.pipe(operators_1.filter(tagsSlice.actions.fetchRequest.match), operators_1.withLatestFrom(state$), operators_1.switchMap(function (_a) {
        var _b = __read(_a, 2), action = _b[0], state = _b[1];
        var query = action.payload.query;
        return rxjs_1.of(action).pipe(
        // Optionally throttle
        debugThrottle_1.default(state.debug.badConnection), 
        // Fetch tags
        operators_1.mergeMap(function () {
            return client_1.client.observable.fetch(query);
        }), 
        // Dispatch complete action
        operators_1.mergeMap(function (result) {
            var items = result.items;
            return rxjs_1.of(tagsSlice.actions.fetchComplete({ tags: items }));
        }), operators_1.catchError(function (error) {
            return rxjs_1.of(tagsSlice.actions.fetchError({
                error: {
                    message: (error === null || error === void 0 ? void 0 : error.message) || 'Internal error',
                    statusCode: (error === null || error === void 0 ? void 0 : error.statusCode) || 500
                }
            }));
        }));
    }));
};
exports.tagsFetchEpic = tagsFetchEpic;
// TODO: merge all buffer epics
// Buffer tag creation via sanity subscriber
var tagsListenerCreateQueueEpic = function (action$) {
    return action$.pipe(operators_1.filter(tagsSlice.actions.listenerCreateQueue.match), operators_1.bufferTime(2000), operators_1.filter(function (actions) { return actions.length > 0; }), operators_1.mergeMap(function (actions) {
        var tags = actions === null || actions === void 0 ? void 0 : actions.map(function (action) { return action.payload.tag; });
        return rxjs_1.of(tagsSlice.actions.listenerCreateQueueComplete({ tags: tags }));
    }));
};
exports.tagsListenerCreateQueueEpic = tagsListenerCreateQueueEpic;
// TODO: merge all buffer epics
// Buffer tag deletion via sanity subscriber
var tagsListenerDeleteQueueEpic = function (action$) {
    return action$.pipe(operators_1.filter(tagsSlice.actions.listenerDeleteQueue.match), operators_1.bufferTime(2000), operators_1.filter(function (actions) { return actions.length > 0; }), operators_1.mergeMap(function (actions) {
        var tagIds = actions === null || actions === void 0 ? void 0 : actions.map(function (action) { return action.payload.tagId; });
        return rxjs_1.of(tagsSlice.actions.listenerDeleteQueueComplete({ tagIds: tagIds }));
    }));
};
exports.tagsListenerDeleteQueueEpic = tagsListenerDeleteQueueEpic;
// TODO: merge all buffer epics
// Buffer tag update via sanity subscriber
var tagsListenerUpdateQueueEpic = function (action$) {
    return action$.pipe(operators_1.filter(tagsSlice.actions.listenerUpdateQueue.match), operators_1.bufferTime(2000), operators_1.filter(function (actions) { return actions.length > 0; }), operators_1.mergeMap(function (actions) {
        var tags = actions === null || actions === void 0 ? void 0 : actions.map(function (action) { return action.payload.tag; });
        return rxjs_1.of(tagsSlice.actions.listenerUpdateQueueComplete({ tags: tags }));
    }));
};
exports.tagsListenerUpdateQueueEpic = tagsListenerUpdateQueueEpic;
// On successful tag creation or updates:
// - Re-sort all tags
var tagsSortEpic = function (action$) {
    return action$.pipe(redux_observable_1.ofType(tagsSlice.actions.listenerCreateQueueComplete.type, tagsSlice.actions.listenerUpdateQueueComplete.type), operators_1.bufferTime(1000), operators_1.filter(function (actions) { return actions.length > 0; }), operators_1.mergeMap(function () { return rxjs_1.of(tagsSlice.actions.sort()); }));
};
exports.tagsSortEpic = tagsSortEpic;
// On tag update request
// - check if tag name already exists
// - throw if tag already exists
// - otherwise, patch document
var tagsUpdateEpic = function (action$, state$) {
    return action$.pipe(operators_1.filter(tagsSlice.actions.updateRequest.match), operators_1.withLatestFrom(state$), operators_1.mergeMap(function (_a) {
        var _b;
        var _c = __read(_a, 2), action = _c[0], state = _c[1];
        var _d = action.payload, closeDialogId = _d.closeDialogId, formData = _d.formData, tag = _d.tag;
        return rxjs_1.of(action).pipe(
        // Optionally throttle
        debugThrottle_1.default(state.debug.badConnection), 
        // Check if tag name is available, throw early if not
        checkTagName_1.default((_b = formData === null || formData === void 0 ? void 0 : formData.name) === null || _b === void 0 ? void 0 : _b.current), 
        // Patch document (Update tag)
        operators_1.mergeMap(function () {
            return rxjs_1.from(client_1.client
                .patch(tag._id)
                .set({ name: { _type: 'slug', current: formData === null || formData === void 0 ? void 0 : formData.name.current } })
                .commit());
        }), 
        // Dispatch complete action
        operators_1.mergeMap(function (updatedTag) {
            return rxjs_1.of(tagsSlice.actions.updateComplete({
                closeDialogId: closeDialogId,
                tag: updatedTag
            }));
        }), operators_1.catchError(function (error) {
            return rxjs_1.of(tagsSlice.actions.updateError({
                error: {
                    message: (error === null || error === void 0 ? void 0 : error.message) || 'Internal error',
                    statusCode: (error === null || error === void 0 ? void 0 : error.statusCode) || 500
                },
                tag: tag
            }));
        }));
    }));
};
exports.tagsUpdateEpic = tagsUpdateEpic;
// Selectors
var selectTagsByIds = function (state) { return state.tags.byIds; };
var selectTagsAllIds = function (state) { return state.tags.allIds; };
exports.selectTags = toolkit_1.createSelector([selectTagsByIds, selectTagsAllIds], function (byIds, allIds) { return allIds.map(function (id) { return byIds[id]; }); });
exports.selectTagById = toolkit_1.createSelector([selectTagsByIds, function (_state, tagId) { return tagId; }], function (byIds, tagId) { return byIds[tagId]; });
// TODO: use createSelector
// Map tag references to react-select options, skipping over items with no linked tags
var selectTagSelectOptions = function (asset) { return function (state) {
    var _a, _b, _c;
    var tags = (_c = (_b = (_a = asset === null || asset === void 0 ? void 0 : asset.opt) === null || _a === void 0 ? void 0 : _a.media) === null || _b === void 0 ? void 0 : _b.tags) === null || _c === void 0 ? void 0 : _c.reduce(function (acc, v) {
        var tagItem = state.tags.byIds[v._ref];
        if (tagItem === null || tagItem === void 0 ? void 0 : tagItem.tag) {
            acc.push(tagItem);
        }
        return acc;
    }, []);
    if (tags && (tags === null || tags === void 0 ? void 0 : tags.length) > 0) {
        return getTagSelectOptions_1.default(tags);
    }
    return null;
}; };
exports.selectTagSelectOptions = selectTagSelectOptions;
exports.tagsActions = tagsSlice.actions;
exports.default = tagsSlice.reducer;
var templateObject_1, templateObject_2;
//# sourceMappingURL=index.js.map