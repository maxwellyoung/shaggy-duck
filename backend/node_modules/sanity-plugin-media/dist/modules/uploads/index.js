"use strict";
var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.uploadsActions = exports.selectUploads = exports.selectUploadById = exports.uploadsCheckRequestEpic = exports.uploadsCompleteQueueEpic = exports.uploadsAssetUploadEpic = exports.uploadsAssetStartEpic = void 0;
var toolkit_1 = require("@reduxjs/toolkit");
var groq_1 = __importDefault(require("groq"));
var rxjs_1 = require("rxjs");
var operators_1 = require("rxjs/operators");
var client_1 = require("../../client");
var constructFilter_1 = __importDefault(require("../../utils/constructFilter"));
var generatePreviewBlobUrl_1 = require("../../utils/generatePreviewBlobUrl");
var uploadSanityAsset_1 = require("../../utils/uploadSanityAsset");
var assets_1 = require("../assets");
var initialState = {
    allIds: [],
    byIds: {}
};
var uploadsSlice = toolkit_1.createSlice({
    name: 'uploads',
    initialState: initialState,
    reducers: {
        checkRequest: function (_state, _action) {
            //
        },
        checkComplete: function (state, action) {
            var results = action.payload.results;
            var assetHashes = Object.keys(results);
            assetHashes.forEach(function (hash) {
                var deleteIndex = state.allIds.indexOf(hash);
                if (deleteIndex >= 0) {
                    state.allIds.splice(deleteIndex, 1);
                }
                if (state.byIds[hash]) {
                    var blobUrl = state.byIds[hash].objectUrl;
                    if (blobUrl) {
                        window.URL.revokeObjectURL(blobUrl);
                    }
                    delete state.byIds[hash];
                }
            });
        },
        previewReady: function (state, action) {
            var _a = action.payload, blobUrl = _a.blobUrl, hash = _a.hash;
            if (state.byIds[hash]) {
                state.byIds[hash].objectUrl = blobUrl;
            }
        },
        uploadCancel: function (state, action) {
            var hash = action.payload.hash;
            var deleteIndex = state.allIds.indexOf(hash);
            if (deleteIndex >= 0) {
                state.allIds.splice(deleteIndex, 1);
            }
            if (state.byIds[hash]) {
                delete state.byIds[hash];
            }
        },
        uploadComplete: function (state, action) {
            var asset = action.payload.asset;
            if (state.byIds[asset.sha1hash]) {
                state.byIds[asset.sha1hash].status = 'complete';
            }
        },
        uploadError: function (state, action) {
            var hash = action.payload.hash;
            var deleteIndex = state.allIds.indexOf(hash);
            if (deleteIndex >= 0) {
                state.allIds.splice(deleteIndex, 1);
            }
            delete state.byIds[hash];
        },
        uploadRequest: function (_state, _action) {
            //
        },
        uploadProgress: function (state, action) {
            var _a = action.payload, event = _a.event, uploadHash = _a.uploadHash;
            state.byIds[uploadHash].percent = event.percent;
            state.byIds[uploadHash].status = 'uploading';
        },
        uploadStart: function (state, action) {
            var uploadItem = action.payload.uploadItem;
            if (!state.allIds.includes(uploadItem.hash)) {
                state.allIds.push(uploadItem.hash);
            }
            state.byIds[uploadItem.hash] = uploadItem;
        }
    }
});
var uploadsAssetStartEpic = function (action$) {
    return action$.pipe(operators_1.filter(exports.uploadsActions.uploadStart.match), operators_1.mergeMap(function (action) {
        var _a = action.payload, file = _a.file, uploadItem = _a.uploadItem;
        return rxjs_1.merge(
        // Generate low res preview
        rxjs_1.of(null).pipe(operators_1.mergeMap(function () { return generatePreviewBlobUrl_1.generatePreviewBlobUrl$(file); }), operators_1.mergeMap(function (url) {
            return rxjs_1.of(exports.uploadsActions.previewReady({
                blobUrl: url,
                hash: uploadItem.hash
            }));
        })), 
        // Upload asset and receive progress / complete events
        rxjs_1.of(null).pipe(
        // delay(500000), // debug uploads
        operators_1.mergeMap(function () { return uploadSanityAsset_1.uploadAsset$(uploadItem.assetType, file, uploadItem.hash); }), operators_1.takeUntil(action$.pipe(operators_1.filter(exports.uploadsActions.uploadCancel.match), operators_1.filter(function (v) { return v.payload.hash === uploadItem.hash; }))), operators_1.mergeMap(function (event) {
            if ((event === null || event === void 0 ? void 0 : event.type) === 'complete') {
                return rxjs_1.of(exports.uploadsActions.uploadComplete({
                    asset: event.asset
                }));
            }
            if ((event === null || event === void 0 ? void 0 : event.type) === 'progress' && (event === null || event === void 0 ? void 0 : event.stage) === 'upload') {
                return rxjs_1.of(exports.uploadsActions.uploadProgress({
                    event: event,
                    uploadHash: uploadItem.hash
                }));
            }
            return rxjs_1.empty();
        }), operators_1.catchError(function (error) {
            return rxjs_1.of(exports.uploadsActions.uploadError({
                error: {
                    message: (error === null || error === void 0 ? void 0 : error.message) || 'Internal error',
                    statusCode: (error === null || error === void 0 ? void 0 : error.statusCode) || 500
                },
                hash: uploadItem.hash
            }));
        })));
    }));
};
exports.uploadsAssetStartEpic = uploadsAssetStartEpic;
var uploadsAssetUploadEpic = function (action$, state$) {
    return action$.pipe(operators_1.filter(exports.uploadsActions.uploadRequest.match), operators_1.withLatestFrom(state$), operators_1.mergeMap(function (_a) {
        var _b = __read(_a, 2), action = _b[0], state = _b[1];
        var _c = action.payload, file = _c.file, forceAsAssetType = _c.forceAsAssetType;
        return rxjs_1.of(action).pipe(
        // Generate SHA1 hash from local file
        operators_1.mergeMap(function () { return uploadSanityAsset_1.hashFile$(file); }), 
        // Ignore if we're unable to generate a hash, or if the file is currently being uploaded
        operators_1.filter(function (hash) {
            if (!hash) {
                return false;
            }
            var exists = !!state.uploads.byIds[hash];
            return !exists;
        }), 
        // Dispatch start action and begin upload process
        operators_1.mergeMap(function (hash) {
            var assetType = forceAsAssetType || (file.type.indexOf('image') >= 0 ? 'image' : 'file');
            var uploadItem = {
                _type: 'upload',
                assetType: assetType,
                hash: hash,
                name: file.name,
                size: file.size,
                status: 'queued'
            };
            return rxjs_1.of(exports.uploadsActions.uploadStart({ file: file, uploadItem: uploadItem }));
        }));
    }));
};
exports.uploadsAssetUploadEpic = uploadsAssetUploadEpic;
var uploadsCompleteQueueEpic = function (action$) {
    return action$.pipe(operators_1.filter(exports.uploadsActions.uploadComplete.match), operators_1.mergeMap(function (action) {
        return rxjs_1.of(exports.uploadsActions.checkRequest({
            assets: [action.payload.asset]
        }));
    }));
};
exports.uploadsCompleteQueueEpic = uploadsCompleteQueueEpic;
var uploadsCheckRequestEpic = function (action$, state$) {
    return action$.pipe(operators_1.filter(exports.uploadsActions.checkRequest.match), operators_1.withLatestFrom(state$), operators_1.mergeMap(function (_a) {
        var _b = __read(_a, 2), action = _b[0], state = _b[1];
        var assets = action.payload.assets;
        var documentIds = assets.map(function (asset) { return asset._id; });
        var constructedFilter = constructFilter_1.default({
            assetTypes: state.assets.assetTypes,
            searchFacets: state.search.facets,
            searchQuery: state.search.query
        });
        var query = groq_1.default(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n        *[", " && _id in $documentIds].sha1hash\n      "], ["\n        *[", " && _id in $documentIds].sha1hash\n      "])), constructedFilter);
        return rxjs_1.of(action).pipe(operators_1.delay(1000), // give Sanity some time to register the recently uploaded asset
        operators_1.mergeMap(function () { return client_1.client.observable.fetch(query, { documentIds: documentIds }); }), operators_1.mergeMap(function (resultHashes) {
            var checkedResults = assets.reduce(function (acc, asset) {
                acc[asset.sha1hash] = resultHashes.includes(asset.sha1hash) ? asset._id : null;
                return acc;
            }, {});
            return rxjs_1.of(exports.uploadsActions.checkComplete({ results: checkedResults }), //
            assets_1.assetsActions.insertUploads({ results: checkedResults }));
        }));
    }));
};
exports.uploadsCheckRequestEpic = uploadsCheckRequestEpic;
// Selectors
var selectUploadsByIds = function (state) { return state.uploads.byIds; };
var selectUploadsAllIds = function (state) { return state.uploads.allIds; };
exports.selectUploadById = toolkit_1.createSelector([
    function (state) { return state.uploads.byIds; },
    function (_state, uploadId) { return uploadId; }
], function (byIds, uploadId) { return byIds[uploadId]; });
exports.selectUploads = toolkit_1.createSelector([selectUploadsByIds, selectUploadsAllIds], function (byIds, allIds) { return allIds.map(function (id) { return byIds[id]; }); });
exports.uploadsActions = uploadsSlice.actions;
exports.default = uploadsSlice.reducer;
var templateObject_1;
//# sourceMappingURL=index.js.map