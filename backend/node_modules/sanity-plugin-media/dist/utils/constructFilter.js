"use strict";
var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var groq_1 = __importDefault(require("groq"));
var searchFacets_1 = require("../config/searchFacets");
var constructFilter = function (_a) {
    var assetTypes = _a.assetTypes, searchFacets = _a.searchFacets, searchQuery = _a.searchQuery;
    // Fetch asset types depending on current context.
    // Either limit to a specific type (if being used as a custom asset source) or fetch both files and images (if being used as a tool)
    // Sanity will crash if you try and insert incompatible asset types into fields!
    var documentAssetTypes = assetTypes.map(function (type) { return "sanity." + type + "Asset"; });
    var baseFilter = groq_1.default(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n    _type in ", " && !(_id in path(\"drafts.**\"))\n  "], ["\n    _type in ", " && !(_id in path(\"drafts.**\"))\n  "])), JSON.stringify(documentAssetTypes));
    var searchFacetFragments = searchFacets.reduce(function (acc, facet) {
        var _a;
        if (facet.type === 'number') {
            var field = facet.field, modifier_1 = facet.modifier, modifiers = facet.modifiers, operatorType = facet.operatorType, value = facet.value;
            var operator = searchFacets_1.operators[operatorType];
            // Get current modifier
            var currentModifier = modifiers === null || modifiers === void 0 ? void 0 : modifiers.find(function (m) { return m.name === modifier_1; });
            // Apply field modifier function (if present)
            var facetField = (currentModifier === null || currentModifier === void 0 ? void 0 : currentModifier.fieldModifier) ? currentModifier.fieldModifier(field)
                : field;
            var fragment = operator.fn(value, facetField);
            if (fragment) {
                acc.push(fragment);
            }
        }
        if (facet.type === 'searchable') {
            var field = facet.field, operatorType = facet.operatorType, value = facet.value;
            var operator = searchFacets_1.operators[operatorType];
            var fragment = operator.fn(value === null || value === void 0 ? void 0 : value.value, field);
            if (fragment) {
                acc.push(fragment);
            }
        }
        if (facet.type === 'select') {
            var field = facet.field, operatorType = facet.operatorType, options = facet.options, value_1 = facet.value;
            var operator = searchFacets_1.operators[operatorType];
            var currentOptionValue = (_a = options === null || options === void 0 ? void 0 : options.find(function (l) { return l.name === value_1; })) === null || _a === void 0 ? void 0 : _a.value;
            var fragment = operator.fn(currentOptionValue, field);
            if (fragment) {
                acc.push(fragment);
            }
        }
        if (facet.type === 'string') {
            var field = facet.field, operatorType = facet.operatorType, value = facet.value;
            var operator = searchFacets_1.operators[operatorType];
            var fragment = operator.fn(value, field);
            if (fragment) {
                acc.push(fragment);
            }
        }
        return acc;
    }, []);
    // Join separate filter fragments
    var constructedQuery = __spread([
        // Base filter
        baseFilter
    ], (searchQuery
        ? [
            groq_1.default(templateObject_2 || (templateObject_2 = __makeTemplateObject(["[_id, altText, assetId, description, originalFilename, title, url] match '*", "*'"], ["[_id, altText, assetId, description, originalFilename, title, url] match '*", "*'"])), searchQuery.trim())
        ]
        : []), searchFacetFragments).join(' && ');
    return constructedQuery;
};
exports.default = constructFilter;
var templateObject_1, templateObject_2;
//# sourceMappingURL=constructFilter.js.map